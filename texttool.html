<!DOCTYPE html>
<html>
<!--Original source: https://github.com/Pinsplash/texttool-->
<!--Last time I remembered to update the build date: October 5, 2025-->
<head>
</head>
<body>
    <form name="form" class="form">
        <table class="copyabletable">
            <tr>
                <td>
                    <label for="targetmodeselect" title="Select what text to target with the effect">Target:</label>
                </td>
                <td>
                    <select name="targetmodeselect" class="targetmodeselect">
                        <option value="alltext">All Text</option>
                        <option value="duplicatelines">Duplicate Lines</option>
                        <option value="emptylines">Empty Lines</option>
                        <option value="withtoken">Lines with Token</option>
                        <option value="without_token">Lines without Token</option>
                        <option value="uniquelines">Unique Lines</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="effectselect" title="Select effect to apply to targeted text">Effect:</label>
                </td>
                <td>
                    <select name="effectselect" class="effectselect">
                        <option value="copy">Copy (Debug)</option>
                        <option value="prefixsuffix">Add Prefix/Suffix</option>
                        <option value="allcombos">All Combinations</option>
                        <option value="camelseparate">Camel Case Separate</option>
                        <option value="clear">Clear</option>
                        <option value="colext">Column Extract</option>
                        <option value="delete">Delete</option>
                        <option value="insertnewline">Insert Newline</option>
                        <option value="replacetable">Replace Table</option>
                        <option value="sort">Sort (all text only)</option>
                    </select>
                </td>
            </tr>
            <tr class="inputtd">
                <td>
                    <label for="input" title="Put original text here">Input:</label>
                </td>
                <td>
                    <textarea class="input inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="replacetabletd intermediary" style="display: none">
                <td>
                    <label for="replacetable" title="Batch find and replace. Instances of odd lines will be replaced with the next line down.">Table:</label>
                </td>
                <td>
                    <textarea class="replacetable inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="colnotd intermediary" style="display: none">
                <td>
                    <label for="colno" title="When interpreting text as a table, which column to extract">Column Number:</label>
                </td>
                <td>
                    <textarea class="colno inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="delimtd intermediary" style="display: none">
                <td>
                    <label for="delim" title="A character or string that indicates where to separate text">Delimiter:</label>
                </td>
                <td>
                    <textarea class="delim inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="tokentd intermediary" style="display: none">
                <td>
                    <label for="token">Token:</label>
                </td>
                <td>
                    <textarea class="token inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="prefixtd intermediary" style="display: none">
                <td>
                    <label for="prefix" title="Prefix to add to text">Prefix:</label>
                </td>
                <td>
                    <textarea class="prefix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="suffixtd intermediary" style="display: none">
                <td>
                    <label for="suffix" title="Suffix to add to text">Suffix:</label>
                </td>
                <td>
                    <textarea class="suffix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="output" title="Edited text appears here!">Output:</label>
                </td>
                <td>
                    <textarea class="output" rows="10" cols="50"></textarea>
                </td>
            </tr>
        </table>
        <button type="button" onclick="AddToChain(this)">Add</button>
    </form>
    <script>
        AddListeners();
        function AddListeners() {
            var inputlistenelems = document.getElementsByClassName("inputeventlisten");
            for (const el of inputlistenelems) {
                el.addEventListener("input", UpdateAllTextBoxes);
            }
            var effectselectelems = document.getElementsByClassName("effectselect");
            for (const el of effectselectelems) {
                el.onchange = UpdateParameters;
            }
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (const el of targetmodeselectelems) {
                el.onchange = UpdateParameters;
            }
        }
        function UpdateAllTextBoxes() {
            UpdateTextBoxes(0);
        }
        function AddToChain(e) {
            var tableelems = document.getElementsByClassName("copyabletable");
            var lasttable = tableelems[tableelems.length - 1];
            var clone1 = lasttable.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone1);
            var clone2 = e.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone2);
            //delete the input box we just cloned - modifiers after the first use the previous mod's output as their input
            var inputelems = document.getElementsByClassName("inputtd");
            if (inputelems.length > 1) {
                var elemnum = inputelems.length - 1;
                var lastinput = inputelems[elemnum];
                lastinput.remove();
            }
            AddListeners();
        }
        function UpdateParameters() {
            //some modes have their own intermediary boxes to set how they work
            //hide everything by default, re-show based on mode
            var intermedelems = document.getElementsByClassName("intermediary");
            for (const el of intermedelems) {
                el.style.display = "none";
            }
            var effectselectelems = document.getElementsByClassName("effectselect");
            for (var iter = 0; iter < effectselectelems.length; iter++) {
                switch (effectselectelems[iter].value) {
                    case "prefixsuffix":
                        document.getElementsByClassName("prefixtd")[iter].style.display = "table-row";
                        document.getElementsByClassName("suffixtd")[iter].style.display = "table-row";
                        break;
                    case "colext":
                        document.getElementsByClassName("colnotd")[iter].style.display = "table-row";
                        document.getElementsByClassName("delimtd")[iter].style.display = "table-row";
                        break;
                    case "replacetable":
                        document.getElementsByClassName("replacetabletd")[iter].style.display = "table-row";
                        break;
                    case "insertnewline":
                    case "allcombos":
                        document.getElementsByClassName("delimtd")[iter].style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
            var targetmodeelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = 0; iter < targetmodeelems.length; iter++) {
                switch (targetmodeelems[iter].value) {
                    case "withtoken":
                    case "without_token":
                        document.getElementsByClassName("tokentd")[iter].style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
        }
        function UpdateTextBoxes(mod_num) {
            var effectselectelems = document.getElementsByClassName("effectselect");
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = mod_num; iter < effectselectelems.length; iter++) {
                var output = document.getElementsByClassName("output")[iter];
                var input;
                //modifiers after the first use the previous mod's output as their input
                if (iter == 0) {
                    input = document.getElementsByClassName("input")[iter];
                }
                else {
                    input = document.getElementsByClassName("output")[iter - 1];
                }

                var pieces = input.value.split("\n");
                var targetmode = targetmodeselectelems[iter];
                var linestoedit = GetTargetLineNums(pieces, targetmode, iter);
                var effect = effectselectelems[iter];
                output.value = EditLines(pieces, effect, iter, linestoedit).join("\n");
            }
        }
        //lines not targeted by the target mode are left undisturbed
        //create a list of line numbers we want to edit
        function GetTargetLineNums(input, targetmode, iter) {
            var targetfunction;
            var numbers = [];
            switch (targetmode.value) {
                case "duplicatelines":
                    targetfunction = (line, iter, input) => { return input.indexOf(line, input.indexOf(line) + 1) >= 0 && line != "<BR>" };
                    break;
                case "uniquelines":
                    targetfunction = (line, iter, input) => { return input.indexOf(line, input.indexOf(line) + 1) == -1 && line != "<BR>" };
                    break;
                case "emptylines":
                    targetfunction = (line, iter, input) => { return line.length == 0 };
                    break;
                case "withtoken":
                    targetfunction = (line, iter, input) => { return line.includes(document.getElementsByClassName("token")[iter].value) == true };
                    break;
                case "without_token":
                    targetfunction = (line, iter, input) => { return line.includes(document.getElementsByClassName("token")[iter].value) == false };
                    break;
                default:
                    console.log("Unknown target mode");
                case "alltext":
                    targetfunction = (line, iter, input) => { return true };
                    break;
            }
            for (var j = 0; j < input.length; j++) {
                if (targetfunction(input[j], iter, input)) {
                    numbers.push(j);
                }
            }
            return numbers;
        }
        function EditLines(input, effect, iter, linestoedit) {
            var output = input;
            var effectfunction;
            switch (effect.value) {
                case "insertnewline":
                    effectfunction = (line, iter) => { return line.replaceAll(document.getElementsByClassName("delim")[iter].value, "\n") };
                    break;
                case "replacetable":
                    effectfunction = (line, iter) => {
                        var table = document.getElementsByClassName("replacetable")[iter].value.split("\n");
                        for (var i = 0; i + 1 < table.length; i += 2) {
                            line = line.replaceAll(table[i], table[i + 1]);
                        }
                        return line;
                    }
                    break;
                //can't really think of how i would go about sorting a subset of the input, but can't think of a very good use case either
                case "sort":
                    return input.sort();
                    break;
                case "prefixsuffix":
                    effectfunction = (line, iter) => { return document.getElementsByClassName("prefix")[iter].value + line + document.getElementsByClassName("suffix")[iter].value };
                    break;
                case "colext":
                    effectfunction = (line, iter) => {
                        var segments = line.split(document.getElementsByClassName("delim")[iter].value);
                        return segments[Math.min(segments.length - 1, document.getElementsByClassName("colno")[iter].value)];
                    }
                    break;
                case "camelseparate":
                    effectfunction = (line, iter) => { return line.replace(/([A-Z])/g, " $1").trim() };
                    break;
                case "delete":
                    effectfunction = (line, iter) => { return "texttoolinternalsignal_delete" };
                    break;
                case "clear":
                    effectfunction = (line, iter) => { return "" };
                    break;
                case "allcombos":
                    var buffer = [];
                    var result = [];
                    for (i = 0; i < input.length; i++) {
                        buffer = [input[i]];
                        var index = 0;
                        while (result[index]) {
                            buffer.push("" + result[index] + document.getElementsByClassName("delim")[iter].value + input[i]);
                            index++;
                        }
                        result = result.concat(buffer);
                    }
                    return result;
                    break;
                default:
                    console.log("Unknown effect");
                case "copy":
                    effectfunction = (line, iter) => { return line };
                    break;
            }
            var deletedlines = 0;
            for (var j = 0; j < linestoedit.length; j++) {
                var linenum = linestoedit[j] - deletedlines;
                output[linenum] = effectfunction(input[linenum], iter);
                if (output[linenum] == "texttoolinternalsignal_delete") {
                    output.splice(linenum, 1);
                    deletedlines++;
                }
            }
            return output;
        }
    </script>
</body>
</html>