<!DOCTYPE html>
<html>
<!--Original source: https://github.com/Pinsplash/texttool-->
<!--Last time I remembered to update the build date: November 3, 2025-->
<head>
</head>
<body>
    <form name="form" class="form">
        <table class="copyabletable">
            <tr>
                <td>
                    <label for="targetmodeselect" title="Select what text to target with the effect">Target:</label>
                </td>
                <td>
                    <select name="targetmodeselect" class="targetmodeselect">
                        <option value="alltext">All Text</option>
                        <option value="duplicatelines">Duplicate Lines</option>
                        <option value="emptylines">Empty Lines</option>
                        <option value="evenlines">Even Lines</option>
                        <option value="withtoken">Lines with Token</option>
                        <option value="without_token">Lines without Token</option>
                        <option value="oddlines">Odd Lines</option>
                        <option value="repeatlines">Repeat Lines</option>
                        <option value="uniquelines">Unique Lines</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="effectselect" title="Select effect to apply to targeted text">Effect:</label>
                </td>
                <td>
                    <select name="effectselect" class="effectselect">
                        <option value="copy">Copy (Debug)</option>
                        <option value="prefixsuffix">Add Prefix/Suffix</option>
                        <option value="allcombos">All Combinations</option>
                        <option value="camelseparate">Camel Case Separate</option>
                        <option value="clear">Clear</option>
                        <option value="colext">Column Extract</option>
                        <option value="delete">Delete</option>
                        <option value="insertnewline">Insert Newline</option>
                        <option value="tabbrackets">Re-Tab By Brackets</option>
                        <option value="replacetable">Replace Table</option>
                        <option value="reverse">Reverse Lines</option>
                        <option value="sort">Sort Alphabetically</option>
                        <option value="sortnumstrings">Sort by # Instances of Substring</option>
                        <option value="tabtable">Tab Table</option>
                    </select>
                </td>
            </tr>
            <tr class="inputtd">
                <td>
                    <label for="input" title="Put original text here">Input:</label>
                </td>
                <td>
                    <textarea class="input inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="replacetabletd intermediary" style="display: none">
                <td>
                    <label for="replacetable" title="Batch find and replace. Instances of odd lines will be replaced with the next line down.">Table:</label>
                </td>
                <td>
                    <textarea class="replacetable inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="desiredtabwidthtd intermediary" style="display: none">
                <td>
                    <label for="desiredtabwidth" title="When working with tabs, the character width of the tabs. Commonly 2, 4, or 8.">Desired Tab Width:</label>
                </td>
                <td>
                    <textarea class="desiredtabwidth inputeventlisten" rows="1" cols="50">4</textarea>
                </td>
            </tr>
            <tr class="colnotd intermediary" style="display: none">
                <td>
                    <label for="colno" title="When interpreting text as a table, which column to extract">Column Number:</label>
                </td>
                <td>
                    <textarea class="colno inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="openbracketstd intermediary" style="display: none">
                <td>
                    <label for="openbrackets" title="Characters that indicate an opening bracket.">Opening Bracket Chars:</label>
                </td>
                <td>
                    <textarea class="openbrackets inputeventlisten" rows="1" cols="50">([{</textarea>
                </td>
            </tr>
            <tr class="closebracketstd intermediary" style="display: none">
                <td>
                    <label for="closebrackets" title="Characters that indicate a closing bracket.">Closing Bracket Chars:</label>
                </td>
                <td>
                    <textarea class="closebrackets inputeventlisten" rows="1" cols="50">)]}</textarea>
                </td>
            </tr>
            <tr class="delimtd intermediary" style="display: none">
                <td>
                    <label for="delim" title="A character or string that indicates where to separate text">Delimiter:</label>
                </td>
                <td>
                    <textarea class="delim inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="tokentd intermediary" style="display: none">
                <td>
                    <label for="token">Token:</label>
                </td>
                <td>
                    <textarea class="token inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="prefixtd intermediary" style="display: none">
                <td>
                    <label for="prefix" title="Prefix to add to text">Prefix:</label>
                </td>
                <td>
                    <textarea class="prefix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="suffixtd intermediary" style="display: none">
                <td>
                    <label for="suffix" title="Suffix to add to text">Suffix:</label>
                </td>
                <td>
                    <textarea class="suffix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="output" title="Edited text appears here!">Output:</label>
                </td>
                <td>
                    <textarea class="output" rows="10" cols="50"></textarea>
                </td>
            </tr>
        </table>
        <button type="button" onclick="AddToChain(this)">Add</button>
    </form>
    <script>
        AddListeners();
        function AddListeners() {
            var inputlistenelems = document.getElementsByClassName("inputeventlisten");
            for (const el of inputlistenelems) {
                el.addEventListener("input", UpdateAllTextBoxes);
            }
            var effectselectelems = document.getElementsByClassName("effectselect");
            for (const el of effectselectelems) {
                el.onchange = UpdateParameters;
            }
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (const el of targetmodeselectelems) {
                el.onchange = UpdateParameters;
            }
        }
        function UpdateAllTextBoxes() {
            UpdateTextBoxes(0);
        }
        function AddToChain(e) {
            var tableelems = document.getElementsByClassName("copyabletable");
            var lasttable = tableelems[tableelems.length - 1];
            var clone1 = lasttable.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone1);
            var clone2 = e.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone2);
            //delete the input box we just cloned - modifiers after the first use the previous mod's output as their input
            var inputelems = document.getElementsByClassName("inputtd");
            if (inputelems.length > 1) {
                var elemnum = inputelems.length - 1;
                var lastinput = inputelems[elemnum];
                lastinput.remove();
            }
            AddListeners();
        }
        function GetElementInTable(iter, elementname) {
            var table = document.getElementsByClassName("copyabletable")[iter];
            var elem = table.getElementsByClassName(elementname)[0];
            /*
            if (table) {
                console.log("copyabletable #" + iter + " exists");
            } else {
                console.log("copyabletable #" + iter + " did not exist");
            }
            if (elem) {
                console.log("element " + elementname + " exists");
            } else {
                console.log("element " + elementname + " did not exist");
            }
            */
            return elem;
        }
        function UpdateParameters() {
            var tableelems = document.getElementsByClassName("copyabletable");
            for (var iter = 0; iter < tableelems.length; iter++) {
                //some modes have their own intermediary boxes to set how they work
                //hide everything by default, re-show based on mode
                var intermedelems = tableelems[iter].getElementsByClassName("intermediary");
                for (const el of intermedelems) {
                    el.style.display = "none";
                }

                var effect = GetElementInTable(iter, "effectselect");
                switch (effect.value) {
                    case "prefixsuffix":
                        GetElementInTable(iter, "prefixtd").style.display = "table-row";
                        GetElementInTable(iter, "suffixtd").style.display = "table-row";
                        break;
                    case "colext":
                        GetElementInTable(iter, "colnotd").style.display = "table-row";
                        GetElementInTable(iter, "delimtd").style.display = "table-row";
                        break;
                    case "replacetable":
                        GetElementInTable(iter, "replacetabletd").style.display = "table-row";
                        break;
                    case "insertnewline":
                    case "allcombos":
                        GetElementInTable(iter, "delimtd").style.display = "table-row";
                        break;
                    case "sortnumstrings":
                        GetElementInTable(iter, "tokentd").style.display = "table-row";
                        break;
                    case "tabtable":
                        GetElementInTable(iter, "desiredtabwidthtd").style.display = "table-row";
                        GetElementInTable(iter, "delimtd").style.display = "table-row";
                        break;
                    case "tabbrackets":
                        GetElementInTable(iter, "openbracketstd").style.display = "table-row";
                        GetElementInTable(iter, "closebracketstd").style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
            var targetmodeelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = 0; iter < targetmodeelems.length; iter++) {
                var targetmode = GetElementInTable(iter, "targetmodeselect");
                switch (targetmode.value) {
                    case "withtoken":
                    case "without_token":
                        GetElementInTable(iter, "tokentd").style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
        }
        function UpdateTextBoxes(mod_num) {
            var tableelems = document.getElementsByClassName("copyabletable");
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = mod_num; iter < tableelems.length; iter++) {
                var output = GetElementInTable(iter, "output");
                var input;
                //modifiers after the first use the previous mod's output as their input
                if (iter == 0) {
                    input = GetElementInTable(iter, "input");
                } else {
                    input = GetElementInTable(iter - 1, "output");
                }

                var pieces = input.value.split("\n");
                var targetmode = targetmodeselectelems[iter];
                var linestoedit = GetTargetLineNums(pieces, targetmode, iter);
                output.value = EditLines(pieces, iter, linestoedit).join("\n");
            }
        }
        //lines not targeted by the target mode are left undisturbed
        //create a list of line numbers we want to edit
        function GetTargetLineNums(input, targetmode, iter) {
            var targetfunction;
            var numbers = [];
            switch (targetmode.value) {
                case "duplicatelines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line, input.indexOf(line) + 1) >= 0 && line != "<BR>" };
                    break;
                case "repeatlines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line) != linenum && line != "<BR>" };
                    break;
                case "uniquelines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line, input.indexOf(line) + 1) == -1 && line != "<BR>" };
                    break;
                case "emptylines":
                    targetfunction = (line, iter, input, linenum) => { return line.length == 0 };
                    break;
                case "withtoken":
                    targetfunction = (line, iter, input, linenum) => { return line.includes(GetElementInTable(iter, "token").value) == true };
                    break;
                case "without_token":
                    targetfunction = (line, iter, input, linenum) => { return line.includes(GetElementInTable(iter, "token").value) == false };
                    break;
                case "evenlines":
                    targetfunction = (line, iter, input, linenum) => { return linenum % 2 == 0 };
                    break;
                case "oddlines":
                    targetfunction = (line, iter, input, linenum) => { return linenum % 2 == 1 };
                    break;
                default:
                    console.log("Unknown target mode");
                case "alltext":
                    targetfunction = (line, iter, input) => { return true };
                    break;
            }
            for (var j = 0; j < input.length; j++) {
                if (targetfunction(input[j], iter, input, j)) {
                    numbers.push(j);
                }
            }
            return numbers;
        }
        var g_iter;
        function compareNumSubstrings(a, b) {
            debugger;
            var token = GetElementInTable(g_iter, "token").value;
            var a_count = a.split(token).length - 1;
            var b_count = b.split(token).length - 1;
            if (a_count < b_count) {
                return -1;
            } else if (a_count > b_count) {
                return 1;
            }
            return 0;
        }
        function EditLines(input, iter, linestoedit) {
            var output = input;
            var effectfunction;
            var effect = GetElementInTable(iter, "effectselect");
            switch (effect.value) {
                case "insertnewline":
                    effectfunction = (line, iter) => { return line.replaceAll(GetElementInTable(iter, "delim").value, "\n") };
                    break;
                case "replacetable":
                    effectfunction = (line, iter) => {
                        var table = GetElementInTable(iter, "replacetable").value.split("\n");
                        for (var i = 0; i + 1 < table.length; i += 2) {
                            line = line.replaceAll(table[i], table[i + 1]);
                        }
                        return line;
                    }
                    break;
                //can't really think of how i would go about sorting a subset of the input, but can't think of a very good use case either
                case "sort":
                    return input.sort();
                    break;
                case "sortnumstrings":
                    g_iter = iter;
                    return input.sort(compareNumSubstrings);
                    break;
                //what we put in one line depends on all the others
                case "tabtable":
                    GetElementInTable(iter, "output").style.tabSize = GetElementInTable(iter, "desiredtabwidth").value;
                    var buffer = input;
                    var tabwidth = GetElementInTable(iter, "desiredtabwidth").value;
                    var delimiter = GetElementInTable(iter, "delim").value;
                    if (!delimiter || !tabwidth || tabwidth == "0") {
                        return [];
                    }
                    //get rid of existing tabs and spaces that come after delimiter
                    for (var j = 0; j < linestoedit.length; j++) {
                        var linenum = linestoedit[j];
                        var segments = buffer[linenum].split(delimiter);
                        //start at one to not disturb first segment's leading whitespace (this would be, say, typical code indentation)
                        for (var k = 1; k < segments.length; k++) {
                            segments[k] = segments[k].trim();
                        }
                        buffer[linenum] = segments.join(delimiter);
                    }
                    //have to loop this because each iteration of tabbing changes the targetcolumns values for subsequent segments
                    var targetcolumns = [];
                    var colno = 0;
                    var maxsegments = 0;
                    //find longest cell in the column and record length in targetcolumns
                    do {
                        for (var j = 0; j < linestoedit.length; j++) {
                            var linenum = linestoedit[j];
                            var line = buffer[linenum];
                            var segments = line.split(delimiter);
                            maxsegments = Math.max(segments.length, maxsegments);
                            var segm = segments[colno];
                            var reallength = segm.length + delimiter.length;
                            var bestlength;
                            if (targetcolumns[colno]) {
                                bestlength = targetcolumns[colno];
                            } else {
                                bestlength = 0;
                            }
                            targetcolumns[colno] = Math.max(bestlength, reallength);
                            //round to next tab interval
                            targetcolumns[colno] = Math.ceil(targetcolumns[colno] / tabwidth) * tabwidth;
                        }
                        colno++;
                        //-1 because last column doesn't need new tabs
                    } while (colno < maxsegments - 1)
                    colno = 0;
                    do {
                        for (var j = 0; j < linestoedit.length; j++) {
                            var linenum = linestoedit[j];
                            var line = buffer[linenum];
                            var segments = line.split(delimiter);
                            var segm = segments[colno].trim();
                            //add new tabs to match targetcolumns
                            var textcolumn = segm.length + delimiter.length;
                            var firsttab = true;
                            while (textcolumn < targetcolumns[colno]) {
                                segments[colno + 1] = "\t" + segments[colno + 1];
                                if (firsttab) {
                                    textcolumn += +tabwidth - (+textcolumn % +tabwidth);
                                } else {
                                    textcolumn += +tabwidth;
                                }
                                firsttab = false;
                            }
                            buffer[linenum] = segments.join(delimiter);
                        }
                        colno++;
                    } while (colno < targetcolumns.length)
                    return buffer;
                    break;
                case "prefixsuffix":
                    effectfunction = (line, iter) => { return GetElementInTable(iter, "prefix").value + line + GetElementInTable(iter, "suffix").value };
                    break;
                case "colext":
                    effectfunction = (line, iter) => {
                        var segments = line.split(GetElementInTable(iter, "delim").value);
                        return segments[Math.min(segments.length - 1, GetElementInTable(iter, "colno").value)];
                    }
                    break;
                case "camelseparate":
                    effectfunction = (line, iter) => { return line.replace(/([A-Z])/g, " $1").trim() };
                    break;
                case "delete":
                    effectfunction = (line, iter) => { return "texttoolinternalsignal_delete" };
                    break;
                case "clear":
                    effectfunction = (line, iter) => { return "" };
                    break;
                case "allcombos":
                    var buffer = [];
                    var result = [];
                    for (i = 0; i < input.length; i++) {
                        buffer = [input[i]];
                        var index = 0;
                        while (result[index]) {
                            buffer.push("" + result[index] + GetElementInTable(iter, "delim").value + input[i]);
                            index++;
                        }
                        result = result.concat(buffer);
                    }
                    return result;
                    break;
                case "reverse":
                    return input.reverse();
                    break;
                case "tabbrackets":
                    var depth = 0;
                    var openchars = GetElementInTable(iter, "openbrackets").value;
                    var closechars = GetElementInTable(iter, "closebrackets").value;
                    for (var j = 0; j < linestoedit.length; j++) {
                        var linenum = linestoedit[j];
                        var line = output[linenum];
                        //must find closing brackets before adding tabs
                        for (var c = 0; c < closechars.length; c++) {
                            var cchar = closechars[c];
                            var hits = line.split(cchar).length - 1;
                            depth -= hits;
                        }
                        //add tabs
                        for (var k = 0; k < depth; k++) {
                            output[linenum] = "\t" + output[linenum];
                        }
                        //find opening brackets
                        for (var c = 0; c < openchars.length; c++) {
                            var ochar = openchars[c];
                            var hits = line.split(ochar).length - 1;
                            depth += hits;
                        }
                    }
                    return output;
                    break;
                default:
                    console.log("Unknown effect");
                case "copy":
                    effectfunction = (line, iter) => { return line };
                    break;
            }
            var deletedlines = 0;
            for (var j = 0; j < linestoedit.length; j++) {
                var linenum = linestoedit[j] - deletedlines;
                output[linenum] = effectfunction(input[linenum], iter);
                if (output[linenum] == "texttoolinternalsignal_delete") {
                    output.splice(linenum, 1);
                    deletedlines++;
                }
            }
            return output;
        }
    </script>
</body>
</html>