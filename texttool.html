<!DOCTYPE html>
<html>
<!--Original source: https://github.com/Pinsplash/texttool-->
<!--Last time I remembered to update the build date: October 26, 2025-->
<head>
</head>
<body>
    <form name="form" class="form">
        <table class="copyabletable">
            <tr>
                <td>
                    <label for="targetmodeselect" title="Select what text to target with the effect">Target:</label>
                </td>
                <td>
                    <select name="targetmodeselect" class="targetmodeselect">
                        <option value="alltext">All Text</option>
                        <option value="duplicatelines">Duplicate Lines</option>
                        <option value="emptylines">Empty Lines</option>
                        <option value="withtoken">Lines with Token</option>
                        <option value="without_token">Lines without Token</option>
                        <option value="repeatlines">Repeat Lines</option>
                        <option value="uniquelines">Unique Lines</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="effectselect" title="Select effect to apply to targeted text">Effect:</label>
                </td>
                <td>
                    <select name="effectselect" class="effectselect">
                        <option value="copy">Copy (Debug)</option>
                        <option value="prefixsuffix">Add Prefix/Suffix</option>
                        <option value="allcombos">All Combinations</option>
                        <option value="camelseparate">Camel Case Separate</option>
                        <option value="clear">Clear</option>
                        <option value="colext">Column Extract</option>
                        <option value="delete">Delete</option>
                        <option value="insertnewline">Insert Newline</option>
                        <option value="replacetable">Replace Table</option>
                        <option value="sort">Sort Alphabetically</option>
                        <option value="sortnumstrings">Sort by # Instances of Substring</option>
                    </select>
                </td>
            </tr>
            <tr class="inputtd">
                <td>
                    <label for="input" title="Put original text here">Input:</label>
                </td>
                <td>
                    <textarea class="input inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="replacetabletd intermediary" style="display: none">
                <td>
                    <label for="replacetable" title="Batch find and replace. Instances of odd lines will be replaced with the next line down.">Table:</label>
                </td>
                <td>
                    <textarea class="replacetable inputeventlisten" rows="10" cols="50"></textarea>
                </td>
            </tr>
            <tr class="colnotd intermediary" style="display: none">
                <td>
                    <label for="colno" title="When interpreting text as a table, which column to extract">Column Number:</label>
                </td>
                <td>
                    <textarea class="colno inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="delimtd intermediary" style="display: none">
                <td>
                    <label for="delim" title="A character or string that indicates where to separate text">Delimiter:</label>
                </td>
                <td>
                    <textarea class="delim inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="tokentd intermediary" style="display: none">
                <td>
                    <label for="token">Token:</label>
                </td>
                <td>
                    <textarea class="token inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="prefixtd intermediary" style="display: none">
                <td>
                    <label for="prefix" title="Prefix to add to text">Prefix:</label>
                </td>
                <td>
                    <textarea class="prefix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr class="suffixtd intermediary" style="display: none">
                <td>
                    <label for="suffix" title="Suffix to add to text">Suffix:</label>
                </td>
                <td>
                    <textarea class="suffix inputeventlisten" rows="1" cols="50"></textarea>
                </td>
            </tr>
            <tr>
                <td>
                    <label for="output" title="Edited text appears here!">Output:</label>
                </td>
                <td>
                    <textarea class="output" rows="10" cols="50"></textarea>
                </td>
            </tr>
        </table>
        <button type="button" onclick="AddToChain(this)">Add</button>
    </form>
    <script>
        AddListeners();
        function AddListeners() {
            var inputlistenelems = document.getElementsByClassName("inputeventlisten");
            for (const el of inputlistenelems) {
                el.addEventListener("input", UpdateAllTextBoxes);
            }
            var effectselectelems = document.getElementsByClassName("effectselect");
            for (const el of effectselectelems) {
                el.onchange = UpdateParameters;
            }
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (const el of targetmodeselectelems) {
                el.onchange = UpdateParameters;
            }
        }
        function UpdateAllTextBoxes() {
            UpdateTextBoxes(0);
        }
        function AddToChain(e) {
            var tableelems = document.getElementsByClassName("copyabletable");
            var lasttable = tableelems[tableelems.length - 1];
            var clone1 = lasttable.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone1);
            var clone2 = e.cloneNode(true);
            document.getElementsByClassName("form")[0].appendChild(clone2);
            //delete the input box we just cloned - modifiers after the first use the previous mod's output as their input
            var inputelems = document.getElementsByClassName("inputtd");
            if (inputelems.length > 1) {
                var elemnum = inputelems.length - 1;
                var lastinput = inputelems[elemnum];
                lastinput.remove();
            }
            AddListeners();
        }
        function GetElementInTable(iter, elementname) {
            var table = document.getElementsByClassName("copyabletable")[iter];
            var elem = table.getElementsByClassName(elementname)[0];
            /*
            if (table) {
                console.log("copyabletable #" + iter + " exists");
            } else {
                console.log("copyabletable #" + iter + " did not exist");
            }
            if (elem) {
                console.log("element " + elementname + " exists");
            } else {
                console.log("element " + elementname + " did not exist");
            }
            */
            return elem;
        }
        function UpdateParameters() {
            var tableelems = document.getElementsByClassName("copyabletable");
            for (var iter = 0; iter < tableelems.length; iter++) {
                //some modes have their own intermediary boxes to set how they work
                //hide everything by default, re-show based on mode
                var intermedelems = tableelems[iter].getElementsByClassName("intermediary");
                for (const el of intermedelems) {
                    el.style.display = "none";
                }

                var effect = GetElementInTable(iter, "effectselect");
                switch (effect.value) {
                    case "prefixsuffix":
                        GetElementInTable(iter, "prefixtd").style.display = "table-row";
                        GetElementInTable(iter, "suffixtd").style.display = "table-row";
                        break;
                    case "colext":
                        GetElementInTable(iter, "colnotd").style.display = "table-row";
                        GetElementInTable(iter, "delimtd").style.display = "table-row";
                        break;
                    case "replacetable":
                        GetElementInTable(iter, "replacetabletd").style.display = "table-row";
                        break;
                    case "insertnewline":
                    case "allcombos":
                        GetElementInTable(iter, "delimtd").style.display = "table-row";
                        break;
                    case "sortnumstrings":
                        GetElementInTable(iter, "tokentd").style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
            var targetmodeelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = 0; iter < targetmodeelems.length; iter++) {
                var targetmode = GetElementInTable(iter, "targetmodeselect");
                switch (targetmode.value) {
                    case "withtoken":
                    case "without_token":
                        GetElementInTable(iter, "tokentd").style.display = "table-row";
                        break;
                    default:
                        break;
                }
                UpdateTextBoxes(iter);
            }
        }
        function UpdateTextBoxes(mod_num) {
            var tableelems = document.getElementsByClassName("copyabletable");
            var targetmodeselectelems = document.getElementsByClassName("targetmodeselect");
            for (var iter = mod_num; iter < tableelems.length; iter++) {
                var output = GetElementInTable(iter, "output");
                var input;
                //modifiers after the first use the previous mod's output as their input
                if (iter == 0) {
                    input = GetElementInTable(iter, "input");
                }
                else {
                    input = GetElementInTable(iter - 1, "output");
                }

                var pieces = input.value.split("\n");
                var targetmode = targetmodeselectelems[iter];
                var linestoedit = GetTargetLineNums(pieces, targetmode, iter);
                output.value = EditLines(pieces, iter, linestoedit).join("\n");
            }
        }
        //lines not targeted by the target mode are left undisturbed
        //create a list of line numbers we want to edit
        function GetTargetLineNums(input, targetmode, iter) {
            var targetfunction;
            var numbers = [];
            switch (targetmode.value) {
                case "duplicatelines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line, input.indexOf(line) + 1) >= 0 && line != "<BR>" };
                    break;
                case "repeatlines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line) != linenum && line != "<BR>" };
                    break;
                case "uniquelines":
                    targetfunction = (line, iter, input, linenum) => { return input.indexOf(line, input.indexOf(line) + 1) == -1 && line != "<BR>" };
                    break;
                case "emptylines":
                    targetfunction = (line, iter, input, linenum) => { return line.length == 0 };
                    break;
                case "withtoken":
                    targetfunction = (line, iter, input, linenum) => { return line.includes(GetElementInTable(iter, "token").value) == true };
                    break;
                case "without_token":
                    targetfunction = (line, iter, input, linenum) => { return line.includes(GetElementInTable(iter, "token").value) == false };
                    break;
                default:
                    console.log("Unknown target mode");
                case "alltext":
                    targetfunction = (line, iter, input) => { return true };
                    break;
            }
            for (var j = 0; j < input.length; j++) {
                if (targetfunction(input[j], iter, input, j)) {
                    numbers.push(j);
                }
            }
            return numbers;
        }
        var g_iter;
        function compareNumSubstrings(a, b) {
            debugger;
            var token = GetElementInTable(g_iter, "token").value;
            console.log("token from table " + g_iter + ": " + token);
            let re = new RegExp(String.raw`\s${token}\s`, "g");
            var a_count = (a.match(re) || []).length;
            var b_count = (b.match(re) || []).length;
            if (a_count < b_count) {
                return -1;
            } else if (a_count > b_count) {
                return 1;
            }
            return 0;
        }
        function EditLines(input, iter, linestoedit) {
            var output = input;
            var effectfunction;
            var effect = GetElementInTable(iter, "effectselect");
            switch (effect.value) {
                case "insertnewline":
                    effectfunction = (line, iter) => { return line.replaceAll(GetElementInTable(iter, "delim").value, "\n") };
                    break;
                case "replacetable":
                    effectfunction = (line, iter) => {
                        var table = GetElementInTable(iter, "replacetable").value.split("\n");
                        for (var i = 0; i + 1 < table.length; i += 2) {
                            line = line.replaceAll(table[i], table[i + 1]);
                        }
                        return line;
                    }
                    break;
                //can't really think of how i would go about sorting a subset of the input, but can't think of a very good use case either
                case "sort":
                    return input.sort();
                    break;
                case "sortnumstrings":
                    g_iter = iter;
                    return input.sort(compareNumSubstrings);
                    break;
                case "prefixsuffix":
                    effectfunction = (line, iter) => { return GetElementInTable(iter, "prefix").value + line + GetElementInTable(iter, "suffix").value };
                    break;
                case "colext":
                    effectfunction = (line, iter) => {
                        var segments = line.split(GetElementInTable(iter, "delim").value);
                        return segments[Math.min(segments.length - 1, GetElementInTable(iter, "colno").value)];
                    }
                    break;
                case "camelseparate":
                    effectfunction = (line, iter) => { return line.replace(/([A-Z])/g, " $1").trim() };
                    break;
                case "delete":
                    effectfunction = (line, iter) => { return "texttoolinternalsignal_delete" };
                    break;
                case "clear":
                    effectfunction = (line, iter) => { return "" };
                    break;
                case "allcombos":
                    var buffer = [];
                    var result = [];
                    for (i = 0; i < input.length; i++) {
                        buffer = [input[i]];
                        var index = 0;
                        while (result[index]) {
                            buffer.push("" + result[index] + GetElementInTable(iter, "delim").value + input[i]);
                            index++;
                        }
                        result = result.concat(buffer);
                    }
                    return result;
                    break;
                default:
                    console.log("Unknown effect");
                case "copy":
                    effectfunction = (line, iter) => { return line };
                    break;
            }
            var deletedlines = 0;
            for (var j = 0; j < linestoedit.length; j++) {
                var linenum = linestoedit[j] - deletedlines;
                output[linenum] = effectfunction(input[linenum], iter);
                if (output[linenum] == "texttoolinternalsignal_delete") {
                    output.splice(linenum, 1);
                    deletedlines++;
                }
            }
            return output;
        }
    </script>
</body>
</html>